# Paystation two-party gateway for ActiveMerchant
#
# Written by Jack Stinchcombe 19 Feb 2015
# Copyright Paystation Ltd info@paystation.co.nz
# http://www.paystation.co.nz
#
#
# Example usage: 
#
# gateway = ActiveMerchant::Billing::PaystationGateway.new({:paystation_id=>'661337 ', :gateway_id=>"CARDPAY"})
# cc = ActiveMerchant::Billing::CreditCard.new(
#	:first_name => 'Test',
#	:last_name  => 'Testing',
# 	:month      => '5',
#	:year       => '2017',
#	:brand      => 'visa',
#	:number     => '4987654321098769')
# result= gateway.purchase(100,cc,{:order_id=>123})
# if (result.success?)
#	msg = "Transaction successful"
# else
#	msg ="Transaction Failed"
# end

module ActiveMerchant #:nodoc:
	module Billing #:nodoc:
		class PaystationGateway < Gateway

			self.default_currency = 'NZD'
			self.money_format = :cents
			self.supported_countries = %w(NZ)
			self.homepage_url = 'http://paystation.co.nz/'
			self.display_name = 'Paystation Payment Gateway'
			self.supported_cardtypes = [:visa, :master, :american_express, :diners_club]

			
			@paystation_cardtype_map =  {
				'master'=>'mastercard',
				'visa'=> 'visa',
				'american_express'=>'amex',
				'diners_club'=>'dinersclub'
				}
			
			# Creates a new PaystationGateway
			#
			# The gateway requires that a valid Paystation ID and Gateway ID be passed
			# in the +options+ hash.
			#
			# ==== Options
			#
			# * <tt>:paystation_id</tt> -- The Paystation ID (REQUIRED)
			# * <tt>:gateway_id</tt> -- The Gateway ID. (REQUIRED)
			# * <tt>:hmac_key</tt> -- An HMAC key supplied by Paystation. (REQUIRED)			
			# * <tt>:test</tt> -- +true+ or +false+. If true, perform transactions in Test mode.
			#   Otherwise, perform transactions in Live mode.
			def initialize(options = {})
				requires!(options, :paystation_id, :gateway_id, :hmac_key)
				@init_options = options
				super
			end
 
			# Perform a purchase
			#
			# ==== Parameters
			#
			# * <tt>money</tt> -- The amount to be purchased as an Integer value in cents.
			# * <tt>creditcard</tt> -- The CreditCard details for the transaction.
			# * <tt>options</tt> -- A hash of optional parameters.		
			# 
			# The options hash can have the  following  Paystation-specific keys:
			# pstn_af, pstn_cu, pstn_mo, pstn_mr, pstn_df, pstn_ct, pstn_mc, pstn_cc, pstn_cu
			# These values get sent to Paystation in the initialisation string -
			# refer to the Paystation API documentation at:
			# http://paystation.co.nz/Paystation-APIs
			# 
			# pstn_cc, pstn_cu, pstn_mc are set using values from the CreditCard object,
			# but can be overridden.
			# pstn_mr is generated by the purchase method, but can be
			# overridden
			# The keys testmode and order_id are also supported.
			
			
			def purchase(money, creditcard, options = {})
				
				opt = @init_options.merge(options)
				
				post = {}
				
				if (opt.has_key?(:pstn_df))
					post['pstn_df'] = opt[:pstn_df].strip
				end
				
				if (creditcard.kind_of?(ActiveMerchant::Billing::CreditCard))

					post['pstn_cn'] = creditcard.number
					
					if creditcard.month.is_a? String
						month =creditcard.month
					else
						month = creditcard.month.to_s
					end
					
					if month.length==1
						month='0'+month
					end					

					if creditcard.year.is_a? String
						year =creditcard.year
					else
						year = creditcard.year.to_s
					end
					
					if year.length==4
						year= year.slice(2,2) #slice = substring
					end
					
					if (post.has_key?('pstn_df') and post['pstn_df'].downcase='mmyy')
						post['pstn_ex'] = month.strip+year.strip
					else
						post['pstn_ex'] = year.strip+month.strip
					end
					
					post['pstn_mc']  = [creditcard.first_name, creditcard.last_name].join(' ').slice(0, 255)
					
					post['pstn_cc'] = creditcard.verification_value if creditcard.verification_value?
					
					supported_cardtypes = ['visa', 'master', 'american_express', 'diners_club']
					paystation_cardtype_map =  {
						'master'=>'mastercard',
						'visa'=> 'visa',
						'american_express'=>'amex',
						'diners_club'=>'dinersclub'
						}
					
					if (supported_cardtypes.include?(creditcard.brand))
						post['pstn_ct'] = paystation_cardtype_map[creditcard.brand]
					end
					
				elsif creditcard.kind_of?(String)
					post['pstn_cn'] = creditcard.strip
					
					if opt.has_key(:expiry)
						post['pstn_ex']= opt[:expiry]
					end
					if opt.has_key(:cvv)
						post['pstn_cc']= opt[:cvv]
					elsif opt.has_key(:csv)
						post['pstn_cc']= opt[:csv]
					elsif opt.has_key(:verification_value)
						post['pstn_cc']= opt[:verification_value]							
					end					
				end
				
				
				post['pstn_cn'] = post['pstn_cn'].gsub(/[^0-9]/,'') #remove non-numeric characters from card number

				if opt.has_key?(:tm) || opt.has_key?(:testmode)
				  post['tm'] = "T" # test mode
				end
				post['pstn_nr'] = "t"
				post['pstn_2p'] = "t"
				time = Time.now.to_i.to_s
				post['pstn_ms'] = (0...20).map { (65 + rand(26)).chr }.join	
				post['pstn_ms'] += "-"+time
				if (opt.has_key?(:order_id))
					post['pstn_ms'] += "-"+opt[:order_id].to_s
				end
				
				
				post['pstn_pi'] = opt[:paystation_id]
				post['pstn_gi'] = opt[:gateway_id]
				
				post['pstn_am'] = money #already in cents hopefully
				valid_card_types = Array['mastercard', 'visa', 'amex', 'dinersclub']
				
				if opt.has_key?(:pstn_ct)
					card_type  = opt(:pstn_ct)
					if (@paystation_cardtype_map.haskey?(card_type))
						post['pstn_ct'] = paystation_cardtype_map[]
					elsif (valid_card_types.include?(card_type) )
						post['pstn_ct'] = card_type
					end
				end

				
				if (opt.has_key?(:pstn_mr))
					post['pstn_mr'] = opt[:pstn_mr]
				elsif (opt.has_key?(:order_id))
					post['pstn_mr'] = opt[:order_id]
				end	
				if (opt.has_key?(:transaction) and not post.has_key?('pstn_mr'))
					post['pstn_mr'] = opt[:transaction]
				elsif (opt.has_key?(:transaction) && post.has_key?('pstn_mr'))
					post['pstn_mr'] = post['pstn_mr']+":"+opt[:transaction]
				end				
				if (opt.has_key?(:pstn_mc))
					post['pstn_mc'] = opt[:pstn_mc]
				end
				post['pstn_mo'] = '';
				if (opt.has_key?(:description))
					post['pstn_mo'] = opt[:description]
				elsif (opt.has_key?(:pstn_mo))
					post['pstn_mo'] = opt[:pstn_mo]
				end
				if (opt.has_key?(:order_id))
					post['pstn_mo'] += "Order id: "+opt[:order_id].to_s
				end
				
				if (opt.has_key?(:pstn_cc))
					post['pstn_cc'] = opt[:pstn_cc]
				end	
				if (opt.has_key?(:pstn_cu))
					post['pstn_cu'] = opt[:pstn_cu]
				end

				if (opt.has_key?(:pstn_af))
					post['pstn_af'] = opt[:pstn_af]
				end						
				post['paystation'] = "_empty"
				
				#Sort the keys in the hash
				post = self.hash_sort(post);
				
				url = "https://paystation.co.nz/direct/paystation.dll"				
				
				if (self.can_do_hmac?())
					#the only way to get the post body is to HTTP POST Request ...
					#so create a request object solely for this purpose, so the
					#hmac data can be created. For the posting of the actual
					#transaction, a separate Net::HTTP::Post is created with
					#the necessary querystring in the URL
					
					turi = URI.parse (url)
					thttps = Net::HTTP.new(turi.host, turi.port)
					thttps.use_ssl = true # if uri.scheme == 'https'
					thttps.verify_mode = OpenSSL::SSL::VERIFY_NONE
					trequest = Net::HTTP::Post.new(turi.request_uri)
					trequest.set_form_data(post)
					post_body = trequest.body
					hmac = self.makeHMAChash(post_body)
					url +="?pstn_HMACTimestamp="+hmac[:pstn_HMACTimestamp]
					url +="&pstn_HMAC="+hmac[:pstn_HMAC]										
					
				end
				
				
				
				uri = URI.parse (url)
				https = Net::HTTP.new(uri.host, uri.port)
				https.use_ssl = true # if uri.scheme == 'https'
				https.verify_mode = OpenSSL::SSL::VERIFY_NONE
				request = Net::HTTP::Post.new(uri.request_uri)				
				response = {}
				
				request.set_form_data(post)
				
				response = https.request(request)
				 
				case response
					when Net::HTTPSuccess then
					  data =response.body
					else 
					  return nil         
				end

				response = {}
				xml = REXML::Document.new(data)        
				xml.elements.each("#{xml.root.name}/*") do |element|
					response[element.name.underscore.to_sym] = element.text
				end

				ec = response[:ec]
				success = (response[:ec].to_i==0)
				
				msg = response[:em]
				
				return Response.new(success,
				  success ? "Transaction approved" : msg+" (EC: "+ec.to_s+")",
				  response,
				  {	:test => (post['tm'] == "T"),
					:error_code=>ec,
					:message =>response[:em]
				  }
				)
					
			end
			
			#sorts a hash alphabetically by its keys ... only works in ruby 1.9.2 and later
			def hash_sort(hash)
				new_hash={}
				hash_keys=hash.keys.sort
				hash_keys.each do |key|
					new_hash[key]=hash[key]
				end
				return new_hash
			end
			
			def can_do_hmac?
				return @init_options.has_key?(:hmac_key)
			end
			
			def makeHMAChash (post_body, key=nil)
			
				#make sure there's an HMAC key about
				if (key == nil and @init_options.has_key?(:hmac_key))
					hmac_key = @init_options[:hmac_key]
				elsif key.kind_of?(String)
					hmac_key = key
				else
					return nil
				end
				
				hmacTimestamp = Time.now.to_i.to_s
				hmacWebserviceName = "paystation"				
								
				hmacBody= [hmacTimestamp].pack("a*")+[hmacWebserviceName].pack("a*")+[post_body].pack("a*")
				hmacHash= Digest::HMAC.hexdigest(hmacBody, hmac_key, Digest::SHA512)
				return {:pstn_HMACTimestamp=>hmacTimestamp, :pstn_HMAC => hmacHash}
			end
		end
	end
end
